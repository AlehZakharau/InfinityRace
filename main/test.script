go.property("car_speed", 1000)
go.property("track_speed", 1)
go.property("max_track_speed", 5)
go.property("track_stage_duration", 100)
go.property("boost_speed", 2)
go.property("boost_duration", 0.5)
go.property("boost_delay", 3)

local file_path = "/Users/alehzakharau/Documents/Defold/Projects/InfinityRace/data/"
local file_track_1_name = "track_1.txt"
local file_track_2_name = "track_2.txt"
local match_pattern = "([^,]*),([^,]*),([^,]*),([^,]*),([^,]*)"

local car_1 = "/go1"
local car_2 = "/go2"

local track_1 = {}
local track_2 = {}
local index_1 = 1
local index_2 = 100
local time = 0

local car_1_moved = true
local car_1_active = false
local car_1_speed
local car_2_moved = true
local car_2_active = false
local car_2_speed

local boost_delay
local boost_duration
local boost_speed
local boost_1 = false
local boost_2 = false

local current_track_car_1
local current_track_index_1
local current_track_car_2
local current_track_index_2

local function init_track(track, path)
	msg.post(".", "acquire_input_focus")
	file = io.open(path)
	for line in io.lines(path) do
		local a, x, y, switcher_status, connector_index = line:match(match_pattern)
		local id = tonumber(a)
		track[id] = {position = vmath.vector3(x, y, 0), switcher = tonumber(switcher_status), connector = tonumber(connector_index)}
	end
	file:close()
end

function init(self)
	car_1_speed = self.car_speed
	car_2_speed = self.car_speed
	boost_speed = self.boost_speed
	boost_delay = self.boost_delay
	boost_duration = self.boost_duration


	local path = file_path .. file_track_1_name
	init_track(track_1, path)
	current_track_car_1 = track_1
	current_track_index_1 = 1
	path = file_path .. file_track_2_name
	init_track(track_2, path)
	current_track_car_2 = track_2
	current_track_index_2 = 2
end

local function kick_opponent(index)
	if current_track_index_1 == current_track_index_2 and math.abs(index_1 - index_2) < 3 then
		print("kick")
	end
end

local function car_1_callback()
	car_1_moved = true
	kick_opponent(index_1)
end
local function car_2_callback()
	car_2_moved = true
	kick_opponent(index_2)
end

local function increment_index(index, track_length, current_track_speed)
	local next_index = index + current_track_speed
	if next_index > track_length then next_index = 1 end
	return next_index
end

local function rotate_car(car, track, index, current_track_speed)
	local current_position = go.get_position(car)
	local next_index = increment_index(index, #track, current_track_speed)
	local target_position = track[next_index].position
	local angle = math.atan2(current_position.x - target_position.x, target_position.y - current_position.y)
	go.set_rotation(vmath.quat_rotation_z(angle), car)
end

local function move_car(track, index, car, current_track_speed, car_speed, callback)
	local current_position = track[index].position
	local next_index = increment_index(index, #track, current_track_speed)
	local target_position = track[next_index].position
	local distance = vmath.length(target_position - current_position)
	local duration = distance / car_speed
	go.animate(car, "position", go.PLAYBACK_ONCE_FORWARD, target_position, go.EASING_LINEAR, duration, 0, callback)
	return next_index
end


local function switch_track(track, index, track_index)
	if track[index].switcher == 1 then
		if track_index == 1 then
			index = track[index].connector
			track = track_2
			track_index = 2
			return track, index, track_index
		else
			index = track[index].connector
			track = track_1
			track_index = 1
			return track, index, track_index
		end
	end
	return track, index, track_index
end

function update(self, dt)
	time = time + dt
	if time > self.track_stage_duration and self.track_speed < self.max_track_speed then
		self.track_speed = self.track_speed + 1
		time = 0
	end
	if car_1_moved == true then
		car_1_moved = false
		index_1 = move_car(current_track_car_1, index_1, car_1, self.track_speed, car_1_speed, car_1_callback)
	end
	if car_2_moved == true then
		car_2_moved = false
		index_2 = move_car(current_track_car_2, index_2, car_2, self.track_speed, car_2_speed, car_2_callback)
	end
	rotate_car(car_1, current_track_car_1, index_1, self.track_speed)
	rotate_car(car_2, current_track_car_2, index_2, self.track_speed)
end

local function enable_speed_boost_1() boost_1 = false  end
local function enable_speed_boost_2() boost_2 = false  end
local function end_speed_boost_1() car_1_speed = car_1_speed / boost_speed end
local function end_speed_boost_2() car_2_speed = car_2_speed / boost_speed end


local function boost(car_speed, boost_status, boost_callback, enable_boost_callback)
	car_speed = car_speed * boost_speed
	boost_status = true
	timer.delay(boost_duration, false, boost_callback)
	timer.delay(boost_delay, false, enable_boost_callback)
	return car_speed, boost_status
end

function on_input(self, action_id, action)
	if action_id == hash("boost_car_1") and action.released and boost_1 == false then
		car_1_speed, boost_1 = boost(car_1_speed, boost_1, end_speed_boost_1, enable_speed_boost_1)
	end
	if action_id == hash("boost_car_2") and action.released and boost_2 == false then
		car_2_speed, boost_2 = boost(car_2_speed, boost_2, end_speed_boost_2, enable_speed_boost_2)
	end
	if action_id == hash("switch_track_1") and action.pressed then
		current_track_car_1, index_1, current_track_index_1 = switch_track(current_track_car_1, index_1, current_track_index_1)
	end
	if action_id == hash("switch_track_2") and action.pressed then
		current_track_car_2, index_2, current_track_index_2 = switch_track(current_track_car_2, index_2, current_track_index_2)
	end
end
