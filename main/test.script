go.property("car_speed", 1000)
go.property("track_speed", 1)
go.property("max_track_speed", 5)
go.property("track_stage_duration", 100)
go.property("boost_speed", 2)
go.property("boost_duration", 0.5)
go.property("boost_delay", 3)

local file_path = "/Users/alehzakharau/Documents/Defold/Projects/InfinityRace/data/"
local file_track_1_name = "track_1.txt"
local file_track_2_name = "track_2.txt"
local match_pattern = "([^,]*),([^,]*),([^,]*),([^,]*),([^,]*)"

local car_1 = "/go1"
local car_2 = "/go2"

local track_1 = {}
local track_2 = {}
local index_1 = 1
local index_2 = 100
local track_speed
local time = 0

local car_1_moved = true
local car_1_active = false
local car_1_speed
local car_2_moved = true
local car_2_active = false
local car_2_speed

local boost_delay
local boost_duration
local boost_speed
local boost_1 = false
local boost_2 = false

local current_track_car_1
local current_track_index_1
local current_track_car_2
local current_track_index_2


local function spawn_bonus()
	return math.random(1, 5)
end

local function initialize_track(track, path)
	msg.post(".", "acquire_input_focus")
	file = io.open(path)
	for line in io.lines(path) do
		local a, x, y, switcher_status, connector_index, bonus_status = line:match(match_pattern)
		local id = tonumber(a)
		track[id] = {position = vmath.vector3(x, y, 0), switcher = tonumber(switcher_status),
					 connector = tonumber(connector_index), bonus = tonumber(bonus_status)}
		if tonumber(bonus_status) == 1 then
			track[id].bonus = spawn_bonus()
		end
	end
	file:close()
end

local function initialize_tracks()
	local path = file_path .. file_track_1_name
	initialize_track(track_1, path)
	current_track_car_1 = track_1
	current_track_index_1 = 1
	path = file_path .. file_track_2_name
	initialize_track(track_2, path)
	current_track_car_2 = track_2
	current_track_index_2 = 2
end

function init(self)
	track_speed = self.track_speed
	car_1_speed, car_2_speed = self.car_speed, self.car_speed
	boost_speed, boost_delay, boost_duration = self.boost_speed, self.boost_delay, self.boost_duration

	initialize_tracks()

	car_1_active, car_2_active = true, true
end


local function enable_car_1() car_1_active = true end
local function enable_car_2() car_2_active = true end

local bonus_respawn_index_1
local bonus_respawn_index_2

local function respawn_bonus_1()
	current_track_car_1[bonus_respawn_index_1].bonus = spawn_bonus()
end
local function respawn_bonus_2()
	current_track_car_2[bonus_respawn_index_2].bonus = spawn_bonus()
end

local function check_car_position()
	if current_track_index_1 == current_track_index_2 and math.abs((index_1 - index_2) - (track_speed - 1)) < 2 then
		return true
	else
		return false
	end
end

local function car_1_callback()
	if car_1_active == true then
		car_1_moved = true
		if check_car_position() == true  and index_1 < index_2 and car_1_active == true then
			car_2_active = false
			car_2_moved = true
			timer.delay(3, false, enable_car_2)
		end
		if current_track_car_1[index_1].bonus > 0 then
			bonus_respawn_index_1 = index_1
			current_track_car_1[index_1].bonus = 0
			timer.delay(3, false, respawn_bonus_1)
			print("bonus")
		end
	end
end
local function car_2_callback()
	if car_2_active == true then
		car_2_moved = true
		if check_car_position() == true  and index_1 > index_2 and car_2_active == true then
			car_1_active = false
			car_1_moved = true
			timer.delay(3, false, enable_car_1)
		end
		if current_track_car_2[index_2].bonus == 1 then
			bonus_respawn_index_2 = index_2
			current_track_car_2[index_2].bonus = 0
			timer.delay(3, false, respawn_bonus_2)
			print("bonus")
		end
	end
end

local function increment_index(index, track_length, current_track_speed)
	local next_index = index + current_track_speed
	if next_index > track_length then next_index = 1 end
	return next_index
end

local function rotate_car(car, track, index, current_track_speed)
	local current_position = go.get_position(car)
	local next_index = increment_index(index, #track, current_track_speed)
	local target_position = track[next_index].position
	local angle = math.atan2(current_position.x - target_position.x, target_position.y - current_position.y)
	go.set_rotation(vmath.quat_rotation_z(angle), car)
end

local function move_car(track, index, car, current_track_speed, car_speed, callback)
	local current_position = track[index].position
	local next_index = increment_index(index, #track, current_track_speed)
	local target_position = track[next_index].position
	local distance = vmath.length(target_position - current_position)
	local duration = distance / car_speed
	go.animate(car, "position", go.PLAYBACK_ONCE_FORWARD, target_position, go.EASING_LINEAR, duration, 0, callback)
	return next_index
end


local function switch_track(track, index, track_index)
	if track[index].switcher == 1 then
		if track_index == 1 then
			index = track[index].connector
			track = track_2
			track_index = 2
			return track, index, track_index
		else
			index = track[index].connector
			track = track_1
			track_index = 1
			return track, index, track_index
		end
	end
	return track, index, track_index
end

function update(self, dt)
	time = time + dt
	if time > self.track_stage_duration and track_speed < self.max_track_speed then
		track_speed = track_speed + 1
		time = 0
	end
	if car_1_moved == true and car_1_active == true then
		car_1_moved = false
		index_1 = move_car(current_track_car_1, index_1, car_1, track_speed, car_1_speed, car_1_callback)
	end
	if car_2_moved == true and car_2_active == true then
		car_2_moved = false
		index_2 = move_car(current_track_car_2, index_2, car_2, track_speed, car_2_speed, car_2_callback)
	end
	if car_1_active == true then
		rotate_car(car_1, current_track_car_1, index_1, track_speed)
	end
	if car_2_active == true then
		rotate_car(car_2, current_track_car_2, index_2, track_speed)
	end
end

local function enable_speed_boost_1() boost_1 = false  end
local function enable_speed_boost_2() boost_2 = false  end
local function end_speed_boost_1() car_1_speed = car_1_speed / boost_speed end
local function end_speed_boost_2() car_2_speed = car_2_speed / boost_speed end


local function boost(car_speed, boost_status, boost_callback, enable_boost_callback)
	car_speed = car_speed * boost_speed
	boost_status = true
	timer.delay(boost_duration, false, boost_callback)
	timer.delay(boost_delay, false, enable_boost_callback)
	return car_speed, boost_status
end

function on_input(self, action_id, action)
	if action_id == hash("boost_car_1") and action.released and boost_1 == false then
		car_1_speed, boost_1 = boost(car_1_speed, boost_1, end_speed_boost_1, enable_speed_boost_1)
	end
	if action_id == hash("boost_car_2") and action.released and boost_2 == false then
		car_2_speed, boost_2 = boost(car_2_speed, boost_2, end_speed_boost_2, enable_speed_boost_2)
	end
	if action_id == hash("switch_track_1") and action.pressed then
		current_track_car_1, index_1, current_track_index_1 = switch_track(current_track_car_1, index_1, current_track_index_1)
	end
	if action_id == hash("switch_track_2") and action.pressed then
		current_track_car_2, index_2, current_track_index_2 = switch_track(current_track_car_2, index_2, current_track_index_2)
	end
end
