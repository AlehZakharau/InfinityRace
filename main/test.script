go.property("car_speed", 1000)
go.property("track_speed", 1)
go.property("track_stage_duration", 100)
go.property("boost_speed", 2)

local file_path = "/Users/alehzakharau/Documents/Defold/Projects/InfinityRace/data/"
local file_track_1_name = "track_1.txt"
local file_track_2_name = "track_2.txt"
local match_pattern = "([^,]*),([^,]*),([^,]*),([^,]*)"

local car_1 = "/go1"
local car_2 = "/go2"

local track_1 = {}
local track_2 = {}
local index_1 = 1
local index_2 = 100
local time = 0

local car_1_moved = true
local car_1_speed
local car_2_moved = true
local car_2_speed


local function init_track(track, path)
	msg.post(".", "acquire_input_focus")
	file = io.open(path)
	for line in io.lines(path) do
		local a, x, y, track_number = line:match(match_pattern)
		local id = tonumber(a)
		track[id] = {position = vmath.vector3(x, y, 0)}
	end
	file:close()
end

function init(self)
	car_1_speed = self.car_speed
	car_2_speed = self.car_speed
	local path = file_path .. file_track_1_name
	init_track(track_1, path)
	path = file_path .. file_track_2_name
	init_track(track_2, path)

end

local function car_1_callback() car_1_moved = true end
local function car_2_callback()car_2_moved = true end

local function increment_index(index, track_length, current_track_speed)
	local next_index = index + current_track_speed
	if next_index > track_length then next_index = 1 end
	return next_index
end

local function rotate_car(car, track, index, current_track_speed)
	local current_position = go.get_position(car)
	local next_index = increment_index(index, #track, current_track_speed)
	local target_position = track[next_index].position
	local angle = math.atan2(current_position.x - target_position.x, target_position.y - current_position.y)
	go.set_rotation(vmath.quat_rotation_z(angle), car)
end

local function move_car(track, index, car, current_track_speed, car_speed, callback)
	local current_position = track[index].position
	local next_index = increment_index(index, #track, current_track_speed)
	local target_position = track[next_index].position
	local distance = vmath.length(target_position - current_position)
	local duration = distance / car_speed
	go.animate(car, "position", go.PLAYBACK_ONCE_FORWARD, target_position, go.EASING_LINEAR, duration, 0, callback)
	return next_index
end

local function switch_track()
	-- switch index
	-- change track
	-- move to connect index
	-- lick opponent
end

function update(self, dt)
	time = time + dt
	if time > self.track_stage_duration and self.track_speed < 5 then
		self.track_speed = self.track_speed + 1
		time = 0
	end
	if car_1_moved == true then
		car_1_moved = false
		index_1 = move_car(track_1, index_1, car_1, self.track_speed, car_1_speed, car_1_callback)
	end
	if car_2_moved == true then
		car_2_moved = false
		index_2 = move_car(track_2, index_2, car_2, self.track_speed, car_2_speed, car_2_callback)
	end
	rotate_car(car_1, current_track_car_1, index_1, self.track_speed)
	rotate_car(car_2, current_track_car_2, index_2, self.track_speed)
end

local function end_speed_boost() car_1_speed = car_1_speed * 0.5 end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		car_1_speed = car_1_speed * self.boost_speed
		timer.delay(2, false, end_speed_boost)
	end
end
